/**
   * Set risk percentage (1-100)
   */
public setRiskPercentage(percentage: number): void {
    if (percentage <= 0 || percentage > 100) {
      throw new Error('Risk percentage must be between 1 and 100');
    }
    this.riskPercentage = percentage;
    console.log(`Risk percentage set to ${percentage}%`);
  }
  
  /**
   * Set minimum profit threshold in USD
   */
  public setMinProfitThreshold(amount: number): void {
    if (amount < 0) {
      throw new Error('Minimum profit threshold cannot be negative');
    }
    this.minProfitThreshold = amount;
    console.log(`Minimum profit threshold set to ${amount}`);
  }
  
  /**
   * Configure stop-loss percentage
   */
  public setStopLossPercentage(percentage: number): void {
    if (percentage <= 0 || percentage > 20) {
      throw new Error('Stop-loss percentage must be between 0 and 20');
    }
    this.stopLossPercentage = percentage;
    console.log(`Stop-loss percentage set to ${percentage}%`);
  }
  
  /**
   * Set minimum liquidity ratio (multiple of trade size)
   */
  public setMinLiquidityRatio(ratio: number): void {
    if (ratio < 1) {
      throw new Error('Minimum liquidity ratio cannot be less than 1');
    }
    this.minLiquidityRatio = ratio;
    console.log(`Minimum liquidity ratio set to ${ratio}x trade size`);
  }
  
  /**
   * Enable/disable volatility-based position sizing
   */
  public setVolatilityScaling(enabled: boolean): void {
    this.volatilityScaling = enabled;
    console.log(`Volatility-based position sizing: ${enabled ? 'Enabled' : 'Disabled'}`);
  }
  
  /**
   * Get list of active stop-losses
   */
  public getActiveStopLosses(): any[] {
    const result = [];
    for (const [id, info] of this.activeStopLosses.entries()) {
      result.push({
        id,
        inputMint: info.inputMint,
        outputMint: info.outputMint,
        entryPrice: info.entryPrice,
        stopPrice: info.stopPrice,
        amount: info.amount,
        signature: info.signature
      });
    }
    return result;
  }  /**
   * Apply account growth factor after profitable trade
   */
  private applyAccountGrowthFactor(): void {
    // Increase base position size by growth factor
    const newBaseSize = this.basePositionSize * this.accountGrowthFactor;
    
    console.log(`Applying ${((this.accountGrowthFactor - 1) * 100).toFixed(1)}% account growth factor`);
    console.log(`Base position size: ${this.basePositionSize.toFixed(2)} → ${newBaseSize.toFixed(2)}`);
    
    this.basePositionSize = newBaseSize;
  }
  
  /**
   * Main trading bot loop
   */
  public async start(): Promise<void> {
    console.log('Starting Solana trading bot with grid and multi-pair trading...');
    
    // Initialize daily tracking
    await this.trackDailyBalance();
    
    // Initial grid creation
    if (this.gridEnabled) {
      // Create initial grid positions for each pair
      for (const [inputMint, outputMint] of this.tokenPairs) {
        const pairKey = `${inputMint}-${outputMint}`;
        const performance = this.activePairs.get(pairKey);
        
        if (!performance) continue;
        
        // Calculate position size based on allocation
        const allocationPercentage = performance.allocationPercentage;
        const positionSize = this.basePositionSize * (allocationPercentage / 100);
        
        console.log(`Creating initial grid for ${pairKey} with size ${positionSize.toFixed(2)}`);
        await this.createGridPositions(inputMint, outputMint, positionSize);
      }
    }
    
    // Main trading loop
    const runTradingCycle = async () => {
      try {
        // Check for a new day
        await this.trackDailyBalance();
        
        // Run grid trading system
        if (this.gridEnabled) {
          await this.runGridTrading();
        }
        
        // Run multi-pair trading
        if (this.multiPairEnabled) {
          await this.runMultiPairTrading();
        }
        
        // Print current performance
        this.printPerformanceSummary();
        
      } catch (error) {
        console.error('Error in trading cycle:', error);
      }
      
      // Schedule next cycle - every 2 minutes for grid checking, more frequent for active trading
      setTimeout(runTradingCycle, 2 * 60 * 1000);
    };
    
    // Start the trading loop
    runTradingCycle();
  }
  
  /**
   * Print performance summary
   */
  private printPerformanceSummary(): void {
    console.log('\n====== PERFORMANCE SUMMARY ======');
    console.log(`Daily P&L: ${this.dailyPnL.toFixed(2)} (${(this.dailyPnL / this.dailyStartBalance * 100).toFixed(2)}% of daily start)`);
    console.log(`Active grid positions: ${Array.from(this.gridPositions.values()).filter(p => p.status === 'open').length}`);
    
    // Print pair performance
    console.log('\nPair Performance:');
    const sortedPairs = Array.from(this.activePairs.values())
      .sort((a, b) => b.profitLoss - a.profitLoss);
    
    sortedPairs.forEach(pair => {
      const winRate = pair.tradesExecuted > 0 ? (pair.tradesWon / pair.tradesExecuted * 100).toFixed(1) : '0.0';
      console.log(`${pair.pair}: ${pair.profitLoss.toFixed(2)}, ${pair.tradesWon}W/${pair.tradesLost}L (${winRate}%), Allocation: ${pair.allocationPercentage.toFixed(1)}%`);
    });
    
    console.log('==================================\n');
  }
  
  /**
   * Get overall performance statistics
   */
  public getPerformanceStats(): any {
    const activeGridCount = Array.from(this.gridPositions.values())
      .filter(p => p.status === 'open')
      .length;
    
    const totalProfitLoss = Array.from(this.activePairs.values())
      .reduce((sum, pair) => sum + pair.profitLoss, 0);
    
    const totalTrades = Array.from(this.activePairs.values())
      .reduce((sum, pair) => sum + pair.tradesExecuted, 0);
    
    const winningTrades = Array.from(this.activePairs.values())
      .reduce((sum, pair) => sum + pair.tradesWon, 0);
    
    const winRate = totalTrades > 0 ? (winningTrades / totalTrades * 100) : 0;
    
    return {
      dailyPnL: this.dailyPnL,
      dailyPnLPercent: this.dailyStartBalance > 0 ? (this.dailyPnL / this.dailyStartBalance * 100) : 0,
      totalProfitLoss,
      activeGridPositions: activeGridCount,
      totalTrades,
      winningTrades,
      winRate,
      pairPerformance: Array.from(this.activePairs.values())
    };
  }  /**
   * Run the grid trading system
   */
  public async runGridTrading(): Promise<void> {
    try {
      // Don't run if grid trading is disabled
      if (!this.gridEnabled) {
        return;
      }
      
      // Check and execute existing grid positions
      await this.checkGridPositions();
      
      // Don't create new grids if we've hit daily loss limit
      if (this.hasHitDailyLossLimit()) {
        return;
      }
      
      // Count active grid positions
      const activePositionCount = Array.from(this.gridPositions.values())
        .filter(pos => pos.status === 'open')
        .length;
      
      // If we have too many active positions, don't create more
      const maxGridPositions = this.gridLevels * this.tokenPairs.length * 2;
      if (activePositionCount >= maxGridPositions) {
        console.log(`Active grid positions (${activePositionCount}) at maximum (${maxGridPositions}), not creating more`);
        return;
      }
      
      // Get pairs that need new grid positions
      const pairsNeedingGrids = this.tokenPairs.filter(([inputMint, outputMint]) => {
        const pairKey = `${inputMint}-${outputMint}`;
        
        // Count existing grids for this pair
        const pairGrids = Array.from(this.gridPositions.values())
          .filter(pos => 
            pos.status === 'open' && 
            (
              (pos.inputMint === inputMint && pos.outputMint === outputMint) ||
              (pos.inputMint === outputMint && pos.outputMint === inputMint)
            )
          );
        
        // If we have fewer than desired grid positions for this pair, create more
        return pairGrids.length < this.gridLevels;
      });
      
      // Create new grid positions for each pair that needs them
      for (const [inputMint, outputMint] of pairsNeedingGrids) {
        const pairKey = `${inputMint}-${outputMint}`;
        const performance = this.activePairs.get(pairKey);
        
        if (!performance) continue;
        
        // Calculate position size based on allocation
        const allocationPercentage = performance.allocationPercentage;
        const positionSize = this.basePositionSize * (allocationPercentage / 100);
        
        // Only create grids if the position size is meaningful
        if (positionSize < 0.1) continue;
        
        console.log(`Creating new grid positions for ${pairKey} with size ${positionSize.toFixed(2)}`);
        
        // Create grid positions
        await this.createGridPositions(inputMint, outputMint, positionSize);
      }
      
    } catch (error) {
      console.error('Error running grid trading:', error);
    }
  }
  
  /**
   * Run multi-pair trading
   */
  public async runMultiPairTrading(): Promise<void> {
    try {
      // Don't run if feature is disabled
      if (!this.multiPairEnabled) {
        return;
      }
      
      // Don't run if we've hit daily loss limit
      if (this.hasHitDailyLossLimit()) {
        console.log('Daily loss limit reached, pausing multi-pair trading');
        return;
      }
      
      console.log(`Running multi-pair trading for ${this.tokenPairs.length} pairs`);
      
      // Execute trades for each pair
      for (const [inputMint, outputMint] of this.tokenPairs) {
        try {
          const pairKey = `${inputMint}-${outputMint}`;
          const performance = this.activePairs.get(pairKey);
          
          if (!performance) continue;
          
          // Calculate position size based on allocation
          const allocationPercentage = performance.allocationPercentage;
          const positionSize = this.basePositionSize * (allocationPercentage / 100);
          
          // Check if we have a positive allocation and meaningful position size
          if (allocationPercentage <= 0 || positionSize < 0.1) continue;
          
          console.log(`\nEvaluating trade for ${pairKey} with allocation ${allocationPercentage.toFixed(1)}% (${positionSize.toFixed(2)})`);
          
          // Execute the trade with scaled position size
          const result = await this.trade(inputMint, outputMint, positionSize);
          
          if (result.transaction) {
            const signature = await this.sendTransaction(result.transaction);
            console.log(`Trade executed for ${pairKey}: ${signature}`);
            
            // Update pair performance
            this.updatePairPerformance(
              inputMint, 
              outputMint, 
              result.profitAmount, 
              result.profitAmount > 0
            );
            
            // Apply account growth factor after profitable trade
            if (result.profitAmount > 0) {
              this.applyAccountGrowthFactor();
            }
          } else {
            console.log(`No trade executed for ${pairKey}: ${result.profitThresholdMet ? 'Profit threshold met but' : 'No profit opportunity'} ${result.liquiditySufficient ? '' : ', insufficient liquidity'}`);
          }
          
        } catch (error) {
          console.error(`Error trading pair ${inputMint}-${outputMint}:`, error);
          // Continue with next pair
        }
      }
      
    } catch (error) {
      console.error('Error running multi-pair trading:', error);
    }
  }  /**
   * Check if we've hit the daily loss limit
   */
  private hasHitDailyLossLimit(): boolean {
    if (this.dailyStartBalance <= 0) return false;
    
    const lossPercentage = (this.dailyPnL / this.dailyStartBalance) * 100;
    const hasHitLimit = lossPercentage <= -this.dailyLossLimit;
    
    if (hasHitLimit) {
      console.log(`‼️ DAILY LOSS LIMIT REACHED: ${lossPercentage.toFixed(2)}% loss exceeds ${this.dailyLossLimit}% limit`);
      console.log(`Starting balance: ${this.dailyStartBalance.toFixed(2)}, Current P&L: ${this.dailyPnL.toFixed(2)}`);
    }
    
    return hasHitLimit;
  }
  
  /**
   * Adjust pair allocations based on performance
   */
  private adjustPairAllocations(): void {
    // Only adjust if we have enough performance data
    const pairs = Array.from(this.activePairs.values());
    const activePairs = pairs.filter(p => p.tradesExecuted > 0);
    
    if (activePairs.length < 2) return;
    
    // Calculate performance score for each pair
    const pairScores = activePairs.map(pair => {
      const winRate = pair.tradesWon / (pair.tradesExecuted || 1);
      const profitFactor = Math.max(0.1, pair.profitLoss);
      // Simple scoring function: win rate * profit
      return {
        pair: pair.pair,
        score: winRate * profitFactor,
        currentAllocation: pair.allocationPercentage
      };
    });
    
    // Sort by score
    pairScores.sort((a, b) => b.score - a.score);
    
    // Redistribute allocations - better performers get more allocation
    const totalScore = pairScores.reduce((sum, p) => sum + p.score, 0);
    
    if (totalScore <= 0) return;
    
    // Ensure minimum allocation and redistribute the rest proportionally
    const minAllocation = 5; // Minimum 5% allocation per pair
    const allocatablePortion = 100 - (minAllocation * activePairs.length);
    
    pairScores.forEach((pairScore, index) => {
      // Calculate new allocation
      let newAllocation = minAllocation;
      if (totalScore > 0) {
        newAllocation += allocatablePortion * (pairScore.score / totalScore);
      }
      
      // Cap at 30% max for any pair to maintain diversification
      newAllocation = Math.min(30, newAllocation);
      
      // Update the allocation
      const performance = this.activePairs.get(pairScore.pair);
      if (performance) {
        // Only make significant changes to avoid thrashing
        if (Math.abs(performance.allocationPercentage - newAllocation) > 3) {
          console.log(`Adjusting allocation for ${pairScore.pair}: ${performance.allocationPercentage.toFixed(1)}% → ${newAllocation.toFixed(1)}%`);
          performance.allocationPercentage = newAllocation;
          this.activePairs.set(pairScore.pair, performance);
        }
      }
    });
    
    // Normalize to ensure allocations sum to 100%
    let totalAllocation = Array.from(this.activePairs.values())
      .reduce((sum, p) => sum + p.allocationPercentage, 0);
    
    if (Math.abs(totalAllocation - 100) > 1) {
      const adjustmentFactor = 100 / totalAllocation;
      for (const [key, performance] of this.activePairs.entries()) {
        performance.allocationPercentage *= adjustmentFactor;
        this.activePairs.set(key, performance);
      }
    }
  }
  
  /**
   * Clean up old grid positions
   */
  private cleanupGridPositions(): void {
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;
    
    let cleanedCount = 0;
    
    for (const [id, position] of this.gridPositions.entries()) {
      // Remove filled positions older than a day
      if (position.status === 'filled' && now - position.placementTime > oneDay) {
        this.gridPositions.delete(id);
        cleanedCount++;
      }
      
      // Remove very old unfilled positions (3 days)
      if (position.status === 'open' && now - position.placementTime > 3 * oneDay) {
        position.status = 'cancelled';
        this.gridPositions.set(id, position);
        
        // Remove after marking as cancelled
        this.gridPositions.delete(id);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      console.log(`Cleaned up ${cleanedCount} old grid positions`);
    }
  }import { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';
import { Market } from '@project-serum/serum';
import { TokenSwap } from '@solana/spl-token-swap';
import { Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import fetch from 'node-fetch';

// Types for our trading bot
interface RouteInfo {
  dex: string;
  expectedOutput: number;
  route: string[];
  estimatedPriceImpact: number;
}

interface TradeResult {
  bestRoute: RouteInfo;
  adaptiveSlippage: number;
  transaction: Transaction | null;
  profitAmount: number;
  profitThresholdMet: boolean;
  executedSize: number;
  originalSize: number;
  liquiditySufficient: boolean;
}

// Grid position tracking
interface GridPosition {
  inputMint: string;
  outputMint: string;
  entryPrice: number;
  size: number;
  targetPrice: number;
  stopPrice: number;
  placementTime: number;
  id: string;
  status: 'open' | 'filled' | 'cancelled';
}

// Token pair performance tracking
interface PairPerformance {
  pair: string;
  tradesExecuted: number;
  tradesWon: number;
  tradesLost: number;
  profitLoss: number;
  lastTradeTime: number;
  allocationPercentage: number;
}

// Market data for risk analysis
interface MarketData {
  volatility24h: number;
  volumeUsd24h: number;
  liquidityDepth: number;
  priceChangePercent: number;
}

class SolanaTradeBot {
  private connection: Connection;
  private wallet: Keypair;
  private jupiterApiUrl = 'https://quote-api.jup.ag/v6'; // Updated to Jupiter v6 API
  private raydiumApiUrl = 'https://api.raydium.io/v2';
  private orcaApiUrl = 'https://api.orca.so/v2';
  
  // Risk management parameters
  private riskPercentage = 30; // Base risk: 30% of account
  private minProfitThreshold = 0.04; // Minimum profit in USD
  private stopLossPercentage = 2.5; // Default stop-loss at 2.5%
  private minLiquidityRatio = 3; // Require 3x trade size in orderbook depth
  private volatilityScaling = true; // Enable dynamic position sizing
  private maxVolatilityPercentage = 10; // Max volatility considered for scaling
  private dailyLossLimit = 3; // Daily loss limit as percentage of account
  private dailyStartBalance = 0; // Starting balance for the day
  private dailyPnL = 0; // Running profit/loss for the day
  
  // Grid trading parameters
  private gridEnabled = true;
  private gridLevels = 10; // Number of grid levels
  private gridSpread = 1.0; // Percentage between grid levels
  private gridAllocation = 0.5; // Percentage of position size per grid
  private gridPositions: Map<string, GridPosition> = new Map();
  
  // Multi-pair trading parameters
  private multiPairEnabled = true;
  private activePairs: Map<string, PairPerformance> = new Map();
  private accountGrowthFactor = 1.015; // 1.5% account growth factor after profits
  private basePositionSize = 0; // Will be calculated as % of account
  
  // Token pairs to trade (top Solana tokens)
  private tokenPairs: Array<[string, string]> = [
    // Base pairs with USDC
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'So11111111111111111111111111111111111111112'], // USDC-SOL
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So'], // USDC-mSOL
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'], // USDC-USDT
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263'], // USDC-BONK
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU'], // USDC-SAMO
    
    // SOL pairs
    ['So11111111111111111111111111111111111111112', '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU'], // SOL-SAMO
    ['So11111111111111111111111111111111111111112', 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263'], // SOL-BONK
    ['So11111111111111111111111111111111111111112', 'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So'], // SOL-mSOL
    
    // Other popular pairs
    ['mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', '7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj'], // mSOL-stSOL
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE'], // USDC-ORCA
  ];
  
  // Tracking for active trades with stop-losses
  private activeStopLosses: Map<string, {
    inputMint: string;
    outputMint: string;
    entryPrice: number;
    amount: number;
    stopPrice: number;
    signature: string;
  }> = new Map();
  
  constructor(rpcEndpoint: string, privateKey: string) {
    this.connection = new Connection(rpcEndpoint, 'confirmed');
    this.wallet = Keypair.fromSecretKey(Buffer.from(privateKey, 'hex'));
    console.log(`Trading bot initialized with wallet: ${this.wallet.publicKey.toString()}`);
    
    // Initialize pair performance tracking
    this.initializePairs();
    
    // Set daily starting balance
    this.trackDailyBalance();
  }
  
  /**
   * Initialize token pairs for multi-pair trading
   */
  private initializePairs() {
    // Initialize performance tracking for each pair
    this.tokenPairs.forEach(([inputMint, outputMint]) => {
      const pairKey = `${inputMint}-${outputMint}`;
      if (!this.activePairs.has(pairKey)) {
        this.activePairs.set(pairKey, {
          pair: pairKey,
          tradesExecuted: 0,
          tradesWon: 0,
          tradesLost: 0,
          profitLoss: 0,
          lastTradeTime: 0,
          allocationPercentage: 100 / this.tokenPairs.length // Equal distribution initially
        });
      }
    });
    
    console.log(`Initialized ${this.activePairs.size} trading pairs`);
  }
  
  /**
   * Track daily balance for loss limit calculation
   */
  private async trackDailyBalance() {
    try {
      // Get USDC balance as reference
      const usdcBalance = await this.getTokenBalance('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
      
      // Get SOL balance and convert to USD
      const solBalance = await this.getTokenBalance('So11111111111111111111111111111111111111112');
      const solPrice = await this.getTokenUsdPrice('So11111111111111111111111111111111111111112');
      const solValueUsd = solBalance * solPrice;
      
      // Calculate total USD value
      const totalBalanceUsd = usdcBalance + solValueUsd;
      
      // Set as daily starting balance if not set yet today
      const today = new Date().toDateString();
      const lastBalanceDay = localStorage.getItem('lastBalanceDay');
      
      if (lastBalanceDay !== today) {
        this.dailyStartBalance = totalBalanceUsd;
        this.dailyPnL = 0;
        localStorage.setItem('lastBalanceDay', today);
        localStorage.setItem('dailyStartBalance', this.dailyStartBalance.toString());
        console.log(`New day detected. Setting starting balance: ${this.dailyStartBalance.toFixed(2)}`);
      } else if (this.dailyStartBalance === 0) {
        // If we're restarting the bot during the same day, load saved value
        const savedBalance = localStorage.getItem('dailyStartBalance');
        if (savedBalance) {
          this.dailyStartBalance = parseFloat(savedBalance);
        } else {
          this.dailyStartBalance = totalBalanceUsd;
        }
        console.log(`Loaded daily starting balance: ${this.dailyStartBalance.toFixed(2)}`);
      }
      
      // Calculate base position size (will be scaled by pair allocation)
      this.basePositionSize = totalBalanceUsd * (this.riskPercentage / 100) / this.tokenPairs.length;
      console.log(`Base position size set to: ${this.basePositionSize.toFixed(2)}`);
      
    } catch (error) {
      console.error('Error tracking daily balance:', error);
      // Use a safe default if balance tracking fails
      if (this.dailyStartBalance === 0) {
        this.dailyStartBalance = 1000; // Arbitrary default
        this.basePositionSize = 10; // Safe small default
      }
    }
  }

  /**
   * Calculate adaptive slippage based on market volatility and trade size
   */
  private calculateAdaptiveSlippage(
    inputAmount: number,
    tokenPair: [string, string],
    priceImpact: number
  ): number {
    // Base slippage starts at 0.5%
    let slippage = 0.5;
    
    // Adjust based on price impact: higher impact = higher slippage tolerance
    if (priceImpact > 1) {
      slippage += priceImpact * 0.5; // Add 0.5% for each 1% of price impact
    }
    
    // Adjust based on trade size: larger trades might need more slippage
    if (inputAmount > 10000) {
      slippage += 0.5; // Add 0.5% for large trades
    }
    
    // Cap maximum slippage at 5% to prevent extreme slippage
    return Math.min(slippage, 5);
  }

  /**
   * Query Jupiter API to get routes across multiple DEXs
   */
  private async getJupiterRoutes(
    inputMint: string, 
    outputMint: string, 
    amount: number,
    slippageBps: number
  ): Promise<any> {
    const params = new URLSearchParams({
      inputMint,
      outputMint,
      amount: amount.toString(),
      slippageBps: slippageBps.toString(),
      feeBps: '4',
      onlyDirectRoutes: 'false',
      asLegacyTransaction: 'false',
      // New Jupiter v6 API parameters
      platformFeeBps: '0',
      excludeDexes: '', // Optionally exclude specific DEXes
      maxAccounts: '64' // Limit transaction size
    });

    const response = await fetch(`${this.jupiterApiUrl}/quote?${params}`);
    return await response.json();
  }

  /**
   * Query Raydium for price quotes
   */
  private async getRaydiumPrice(
    inputMint: string,
    outputMint: string,
    amount: number
  ): Promise<RouteInfo | null> {
    try {
      // Use Raydium's latest API endpoints
      const response = await fetch(`${this.raydiumApiUrl}/main/price?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippage=0.5`);
      const data = await response.json();
      
      return {
        dex: 'Raydium',
        expectedOutput: data.outAmount,
        route: [inputMint, outputMint],
        estimatedPriceImpact: data.priceImpact
      };
    } catch (error) {
      console.error('Error fetching Raydium price:', error);
      return null;
    }
  }

  /**
   * Query Orca for price quotes
   */
  private async getOrcaPrice(
    inputMint: string,
    outputMint: string,
    amount: number
  ): Promise<RouteInfo | null> {
    try {
      // Use Orca's latest API endpoints
      const response = await fetch(`${this.orcaApiUrl}/prices?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippage=50`);
      const data = await response.json();
      
      return {
        dex: 'Orca',
        expectedOutput: data.outAmount,
        route: [inputMint, outputMint],
        estimatedPriceImpact: data.priceImpact
      };
    } catch (error) {
      console.error('Error fetching Orca price:', error);
      return null;
    }
  }

  /**
   * Query Serum/OpenBook markets for price quotes
   */
  private async getSerumPrice(
    inputMint: string,
    outputMint: string,
    amount: number
  ): Promise<RouteInfo | null> {
    try {
      // Note: Serum is now part of OpenBook. We'll need to use on-chain methods
      // to fetch prices directly from markets rather than relying on an API
      
      // This is a simplified placeholder. In a real implementation, you would:
      // 1. Find the market address for the input/output pair
      // 2. Load the market using @openbook-dex/openbook library
      // 3. Fetch the orderbook and calculate price impact
      
      const marketAddress = await this.findMarketAddress(inputMint, outputMint);
      if (!marketAddress) {
        console.log('No OpenBook market found for this pair');
        return null;
      }
      
      const market = await Market.load(
        this.connection,
        new PublicKey(marketAddress),
        {},
        new PublicKey('srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX') // OpenBook program ID
      );
      
      const { bids, asks } = await market.loadOrderbook(this.connection);
      
      // Calculate expected output based on orderbook depth
      let remainingAmount = amount;
      let totalOutput = 0;
      
      // Simplified order matching (in reality, this is more complex)
      for (const ask of asks) {
        const orderSize = ask.size;
        const price = ask.price;
        
        if (remainingAmount <= 0) break;
        
        const fillAmount = Math.min(remainingAmount, orderSize);
        totalOutput += fillAmount * price;
        remainingAmount -= fillAmount;
      }
      
      // Estimate price impact
      const estimatedPriceImpact = amount > 0 ? (1 - (totalOutput / amount)) * 100 : 0;
      
      return {
        dex: 'OpenBook',
        expectedOutput: totalOutput,
        route: [inputMint, outputMint],
        estimatedPriceImpact: estimatedPriceImpact
      };
    } catch (error) {
      console.error('Error fetching OpenBook price:', error);
      return null;
    }
  }
  
  /**
   * Helper method to find OpenBook market address for a token pair
   */
  private async findMarketAddress(inputMint: string, outputMint: string): Promise<string | null> {
    // In a real implementation, you would query a registry or use known market addresses
    // This is a placeholder
    
    // Example: USDC/SOL market on OpenBook
    if ((inputMint === 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' && 
         outputMint === 'So11111111111111111111111111111111111111112') ||
        (inputMint === 'So11111111111111111111111111111111111111112' && 
         outputMint === 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')) {
      return '9wFFyRfZBsuAha4YcuxcXLKwMxJR43S7fPfQLusDBzvT'; // OpenBook USDC/SOL market
    }
    
    return null;
  }

  /**
   * Find the best price across all DEXs
   */
  private async findBestPrice(
    routes: RouteInfo[]
  ): Promise<RouteInfo | null> {
    if (routes.length === 0) {
      return null;
    }
    
    // Sort by expected output in descending order (higher is better)
    const sortedRoutes = routes.sort((a, b) => b.expectedOutput - a.expectedOutput);
    return sortedRoutes[0];
  }

  /**
   * Execute the trade using the best route
   */
  private async executeTrade(
    inputMint: string,
    outputMint: string,
    amount: number,
    bestRoute: RouteInfo,
    slippage: number
  ): Promise<Transaction | null> {
    try {
      if (bestRoute.dex === 'Jupiter') {
        // Execute via Jupiter
        const slippageBps = Math.floor(slippage * 100); // Convert percentage to basis points
        const response = await fetch(`${this.jupiterApiUrl}/swap`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            route: bestRoute,
            userPublicKey: this.wallet.publicKey.toString(),
            slippageBps
          })
        });
        
        const { swapTransaction } = await response.json();
        
        // Deserialize and sign the transaction
        const transaction = Transaction.from(Buffer.from(swapTransaction, 'base64'));
        transaction.partialSign(this.wallet);
        
        return transaction;
      } else {
        // In a real implementation, you would implement trade execution for each DEX
        console.log(`Trade execution for ${bestRoute.dex} not implemented yet`);
        return null;
      }
    } catch (error) {
      console.error('Error executing trade:', error);
      return null;
    }
  }

  /**
   * Get account balance for a specific token
   */
  private async getTokenBalance(mint: string): Promise<number> {
    try {
      const tokenAccount = await Token.getAssociatedTokenAddress(
        TOKEN_PROGRAM_ID,
        new PublicKey(mint),
        this.wallet.publicKey
      );
      
      const info = await this.connection.getTokenAccountBalance(tokenAccount);
      return parseFloat(info.value.amount) / (10 ** info.value.decimals);
    } catch (error) {
      console.error(`Error fetching token balance for ${mint}:`, error);
      return 0;
    }
  }

  /**
   * Fetch market data for dynamic position sizing and liquidity analysis
   */
  private async getMarketData(inputMint: string, outputMint: string): Promise<MarketData> {
    try {
      // Jupiter v6 doesn't have a direct price history endpoint, use the correct one
      // This is the corrected endpoint structure
      const response = await fetch(`https://price.jup.ag/v4/price?ids=${outputMint}&vsToken=USDC`);
      const priceData = await response.json();
      
      // Calculate volatility using available data
      let volatility = 3; // Default volatility percentage if calculation fails
      let priceChangePercent = 0;
      
      if (priceData && priceData.data && priceData.data[outputMint]) {
        const token = priceData.data[outputMint];
        if (token.priceChange24h) {
          // Convert price change to absolute percentage
          priceChangePercent = Math.abs(token.priceChange24h * 100);
          // Use price change as a volatility proxy when full history isn't available
          volatility = Math.max(2, priceChangePercent * 0.8);
        }
      }
      
      // Fetch liquidity depth using v6 correct endpoint
      const depthResponse = await fetch(`${this.jupiterApiUrl}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=1000000&slippageBps=50&onlyDirectRoutes=false`);
      const depthData = await depthResponse.json();
      
      let liquidityDepth = 1000000; // Default safe value
      let volumeUsd24h = 1000000;
      
      if (depthData && depthData.data && depthData.data.length > 0) {
        // Estimate liquidity from best route data
        const bestRoute = depthData.data[0];
        liquidityDepth = bestRoute.otherAmountThreshold * 
                        (await this.getTokenUsdPrice(outputMint));
        
        // Use marketInfos to estimate volume (simplified)
        volumeUsd24h = liquidityDepth * 0.2; // Estimate as 20% of liquidity
      }
      
      console.log(`Market data: Volatility ${volatility.toFixed(2)}%, Liquidity ${liquidityDepth.toFixed(2)}`);
      
      return {
        volatility24h: volatility,
        volumeUsd24h,
        liquidityDepth,
        priceChangePercent
      };
    } catch (error) {
      console.error('Error fetching market data:', error);
      // Return default values if API calls fail
      return {
        volatility24h: 5, // Default to 5% volatility
        volumeUsd24h: 1000000,
        liquidityDepth: 1000000,
        priceChangePercent: 0
      };
    }
  }

  /**
   * Calculate maximum trade amount based on risk percentage and market volatility
   */
  private async calculateMaxTradeAmount(
    inputMint: string, 
    outputMint: string,
    inputAmount: number
  ): Promise<{maxAmount: number, volatilityAdjusted: boolean, liquiditySufficient: boolean}> {
    // Get base amount from account balance and risk percentage
    const balance = await this.getTokenBalance(inputMint);
    let maxAmount = balance * (this.riskPercentage / 100);
    
    // Get market data for volatility adjustment
    const marketData = await this.getMarketData(inputMint, outputMint);
    const volatilityAdjusted = this.volatilityScaling;
    
    // Apply volatility scaling if enabled
    if (this.volatilityScaling) {
      // Cap volatility at maximum percentage
      const cappedVolatility = Math.min(marketData.volatility24h, this.maxVolatilityPercentage);
      
      // Adjustment factor: Higher volatility = smaller position
      // 1% volatility = 100% of base size, 10% volatility = 10% of base size
      const volatilityFactor = cappedVolatility / 100;
      const inverseVolatilityMultiplier = Math.max(0.1, 1 - volatilityFactor * 9);
      
      // Apply the multiplier
      maxAmount = maxAmount * inverseVolatilityMultiplier;
      
      console.log(`Volatility adjustment: ${cappedVolatility.toFixed(2)}% volatility → ${(inverseVolatilityMultiplier * 100).toFixed(0)}% of base size`);
    }
    
    // Check if there's sufficient liquidity for this trade
    const inputValueUsd = inputAmount * (await this.getTokenUsdPrice(inputMint));
    const liquiditySufficient = marketData.liquidityDepth >= inputValueUsd * this.minLiquidityRatio;
    
    if (!liquiditySufficient) {
      console.log(`⚠️ Insufficient liquidity: ${marketData.liquidityDepth.toFixed(2)} available vs ${(inputValueUsd * this.minLiquidityRatio).toFixed(2)} required (${this.minLiquidityRatio}x trade size)`);
    }
    
    return { 
      maxAmount, 
      volatilityAdjusted, 
      liquiditySufficient 
    };
  }

  /**
   * Create grid positions for a token pair
   */
  private async createGridPositions(
    inputMint: string,
    outputMint: string,
    baseAmount: number
  ): Promise<GridPosition[]> {
    try {
      // Get current market price
      const currentPrice = await this.getCurrentPrice(inputMint, outputMint);
      if (currentPrice <= 0) {
        console.error('Invalid current price, cannot create grid');
        return [];
      }
      
      const gridPositions: GridPosition[] = [];
      
      // Calculate grid price levels
      // Half of levels below current price, half above
      const gridStep = this.gridSpread / 100;
      const gridRange = this.gridLevels / 2;
      
      // Amount per grid level (reduced from base amount)
      const amountPerGrid = baseAmount * (this.gridAllocation / 100);
      
      // Create grid levels
      for (let i = -gridRange; i <= gridRange; i++) {
        // Skip the exact current price level (i=0)
        if (i === 0) continue;
        
        // Calculate target price for this grid level
        const priceMultiplier = 1 + (i * gridStep);
        const targetPrice = currentPrice * priceMultiplier;
        
        // For buy orders (below current price)
        if (i < 0) {
          const stopPrice = targetPrice * (1 - this.stopLossPercentage / 100);
          
          const gridPosition: GridPosition = {
            inputMint,
            outputMint,
            entryPrice: targetPrice,
            size: amountPerGrid,
            targetPrice: targetPrice * 1.02, // 2% profit target
            stopPrice,
            placementTime: Date.now(),
            id: `grid-${inputMint}-${outputMint}-${Date.now()}-${i}`,
            status: 'open'
          };
          
          gridPositions.push(gridPosition);
        }
        // For sell orders (above current price)
        else {
          // For sell orders, we're selling the output token
          const stopPrice = targetPrice * (1 - this.stopLossPercentage / 100);
          
          const gridPosition: GridPosition = {
            inputMint: outputMint, // Reversed for sell orders
            outputMint: inputMint, // Reversed for sell orders
            entryPrice: targetPrice,
            size: amountPerGrid / currentPrice, // Convert to output token amount
            targetPrice: targetPrice * 0.98, // 2% profit target (lower price for sell)
            stopPrice,
            placementTime: Date.now(),
            id: `grid-${outputMint}-${inputMint}-${Date.now()}-${i}`,
            status: 'open'
          };
          
          gridPositions.push(gridPosition);
        }
      }
      
      // Store the grid positions
      gridPositions.forEach(position => {
        this.gridPositions.set(position.id, position);
      });
      
      console.log(`Created ${gridPositions.length} grid positions for ${inputMint}-${outputMint}`);
      return gridPositions;
      
    } catch (error) {
      console.error('Error creating grid positions:', error);
      return [];
    }
  }
  
  /**
   * Get current price for a token pair
   */
  private async getCurrentPrice(
    inputMint: string,
    outputMint: string
  ): Promise<number> {
    try {
      const inputPrice = await this.getTokenUsdPrice(inputMint);
      const outputPrice = await this.getTokenUsdPrice(outputMint);
      
      // Handle stablecoin pairs differently
      const isInputStable = this.isStablecoin(inputMint);
      const isOutputStable = this.isStablecoin(outputMint);
      
      if (isInputStable && isOutputStable) {
        // For stable-to-stable, price should be close to 1
        return outputPrice / inputPrice;
      } else if (isInputStable) {
        // Input is stable, output is token
        return 1 / outputPrice;
      } else if (isOutputStable) {
        // Input is token, output is stable
        return inputPrice;
      } else {
        // Both are non-stable tokens
        return inputPrice / outputPrice;
      }
    } catch (error) {
      console.error('Error getting current price:', error);
      return 0;
    }
  }
  
  /**
   * Check if a token is a stablecoin
   */
  private isStablecoin(mint: string): boolean {
    const stablecoins = [
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
      'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT
      'DUSTawucrTsGU8hcqRdHDCbuYhCPADMLM2VcCb8VnFnQ', // DUST
      'USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX', // USDH
    ];
    
    return stablecoins.includes(mint);
  }

  /**
   * Estimate potential profit for a trade
   */
  private async estimatePotentialProfit(
    inputMint: string,
    outputMint: string,
    inputAmount: number,
    expectedOutputAmount: number
  ): Promise<number> {
    const inputTokenPrice = await this.getTokenUsdPrice(inputMint);
    const outputTokenPrice = await this.getTokenUsdPrice(outputMint);
    
    const inputValueUsd = inputAmount * inputTokenPrice;
    const outputValueUsd = expectedOutputAmount * outputTokenPrice;
    
    return outputValueUsd - inputValueUsd;
  }

  /**
   * Main method to trade tokens
   */
  public async trade(
    inputMint: string,
    outputMint: string,
    amount: number
  ): Promise<TradeResult> {
    console.log(`Trading ${amount} of ${inputMint} for ${outputMint}...`);
    
    // Store original requested amount
    const originalAmount = amount;
    
    // 1. Apply dynamic position sizing based on volatility
    const { maxAmount, volatilityAdjusted, liquiditySufficient } = 
      await this.calculateMaxTradeAmount(inputMint, outputMint, amount);
    
    if (amount > maxAmount) {
      console.log(`Trade amount ${amount} exceeds risk-adjusted limit. Reducing to ${maxAmount.toFixed(4)}`);
      amount = maxAmount;
    }
    
    // If liquidity is insufficient, we'll still check prices but may not execute
    if (!liquiditySufficient) {
      console.log(`Warning: Liquidity appears insufficient for this trade size. Proceeding with caution.`);
    }
    
    // 2. Get quotes from all DEXs
    const [jupiterRoutes, raydiumPrice, orcaPrice, serumPrice] = await Promise.all([
      this.getJupiterRoutes(inputMint, outputMint, amount, 50), // 50 bps = 0.5%
      this.getRaydiumPrice(inputMint, outputMint, amount),
      this.getOrcaPrice(inputMint, outputMint, amount),
      this.getSerumPrice(inputMint, outputMint, amount)
    ]);
    
    // 3. Prepare routes from all DEXs
    const routes: RouteInfo[] = [];
    
    // Add Jupiter routes (which already include cross-DEX routing)
    if (jupiterRoutes && jupiterRoutes.data) {
      const jupiterBestRoute = jupiterRoutes.data.reduce((best: any, current: any) => {
        return (!best || current.outAmount > best.outAmount) ? current : best;
      }, null);
      
      if (jupiterBestRoute) {
        routes.push({
          dex: 'Jupiter',
          expectedOutput: parseFloat(jupiterBestRoute.outAmount) / (10 ** 9), // Convert from lamports
          route: jupiterBestRoute.marketInfos.map((info: any) => info.label),
          estimatedPriceImpact: jupiterBestRoute.priceImpactPct
        });
      }
    }
    
    // Add individual DEX routes if available
    if (raydiumPrice) routes.push(raydiumPrice);
    if (orcaPrice) routes.push(orcaPrice);
    if (serumPrice) routes.push(serumPrice);
    
    // 4. Find the best price
    const bestRoute = await this.findBestPrice(routes);
    
    if (!bestRoute) {
      console.error('No routes found for this trade');
      return {
        bestRoute: {
          dex: 'None',
          expectedOutput: 0,
          route: [],
          estimatedPriceImpact: 0
        },
        adaptiveSlippage: 0,
        transaction: null,
        profitAmount: 0,
        profitThresholdMet: false,
        executedSize: 0,
        originalSize: originalAmount,
        liquiditySufficient: false
      };
    }
    
    // 4. Calculate adaptive slippage
    const adaptiveSlippage = this.calculateAdaptiveSlippage(
      amount,
      [inputMint, outputMint],
      bestRoute.estimatedPriceImpact
    );
    
    console.log(`Best route: ${bestRoute.dex} with expected output: ${bestRoute.expectedOutput}`);
    console.log(`Route path: ${bestRoute.route.join(' -> ')}`);
    console.log(`Adaptive slippage: ${adaptiveSlippage}%`);
    
    // 4.5 Calculate potential profit and check threshold
    const potentialProfit = await this.estimatePotentialProfit(
      inputMint,
      outputMint,
      amount,
      bestRoute.expectedOutput
    );
    
    const profitThresholdMet = potentialProfit >= this.minProfitThreshold;
    
    console.log(`Potential profit: ${potentialProfit.toFixed(4)}`);
    console.log(`Profit threshold met: ${profitThresholdMet}`);
    
    // 5. Execute the trade only if profit threshold is met
    let transaction = null;
    if (profitThresholdMet) {
      transaction = await this.executeTrade(
        inputMint,
        outputMint,
        amount,
        bestRoute,
        adaptiveSlippage
      );
      console.log('Trade executed: Profit threshold met');
    } else {
      console.log('Trade skipped: Profit threshold not met');
    }
    
    return {
      bestRoute,
      adaptiveSlippage,
      transaction,
      profitAmount: potentialProfit,
      profitThresholdMet
    };
  }

  /**
   * Send a signed transaction to the network
   */
  /**
   * Monitor a position for stop-loss trigger - Cloud-friendly implementation
   */
  private async monitorStopLoss(stopLossId: string): Promise<void> {
    const stopLossInfo = this.activeStopLosses.get(stopLossId);
    if (!stopLossInfo) return;
    
    console.log(`Starting stop-loss monitor for ${stopLossId}`);
    
    // Use a more robust approach for cloud environments
    // Instead of an interval that runs forever, we'll use a scheduled check
    // that reschedules itself, with proper error handling
    const checkStopLoss = async () => {
      try {
        // Check if this stop-loss is still active
        if (!this.activeStopLosses.has(stopLossId)) {
          console.log(`Stop-loss ${stopLossId} is no longer active, stopping monitor`);
          return; // Exit the recursion
        }
        
        // Get current market price
        const inputPrice = await this.getTokenUsdPrice(stopLossInfo.inputMint);
        const outputPrice = await this.getTokenUsdPrice(stopLossInfo.outputMint);
        const currentPrice = inputPrice / outputPrice;
        
        console.log(`Stop-loss check: Current price ${currentPrice.toFixed(6)} vs Stop price ${stopLossInfo.stopPrice.toFixed(6)}`);
        
        // Check if stop-loss is triggered
        if (currentPrice <= stopLossInfo.stopPrice) {
          console.log(`🚨 Stop-loss triggered! Current price (${currentPrice.toFixed(6)}) below stop price (${stopLossInfo.stopPrice.toFixed(6)})`);
          
          // Execute the sell (reversed trade)
          const result = await this.trade(
            stopLossInfo.inputMint,
            stopLossInfo.outputMint,
            stopLossInfo.amount
          );
          
          if (result.transaction) {
            const signature = await this.sendTransaction(result.transaction);
            console.log(`Stop-loss executed: ${signature}`);
          }
          
          // Remove from active monitoring
          this.activeStopLosses.delete(stopLossId);
          return; // No need to schedule again
        }
        
        // Schedule next check with exponential backoff
        // Every 30 seconds (30000ms) is sufficient for stop-loss monitoring
        // to prevent excessive API calls in cloud environment
        setTimeout(checkStopLoss, 30000);
      } catch (error) {
        console.error(`Error in stop-loss monitoring for ${stopLossId}:`, error);
        // If there's an error, still try again but with a delay
        setTimeout(checkStopLoss, 60000); // Longer delay after error
      }
    };
    
    // Start the initial check
    checkStopLoss();
    
    // Clean up after 24 hours regardless (prevent memory leaks)
    setTimeout(() => {
      if (this.activeStopLosses.has(stopLossId)) {
        this.activeStopLosses.delete(stopLossId);
        console.log(`Stop-loss monitor for ${stopLossId} removed after 24h timeout`);
      }
    }, 24 * 60 * 60 * 1000);
  }

  /**
   * Send a transaction to the network and update any relevant tracking
   */
  public async sendTransaction(transaction: Transaction): Promise<string> {
    const signature = await this.connection.sendRawTransaction(
      transaction.serialize()
    );
    
    await this.connection.confirmTransaction(signature, 'confirmed');
    console.log(`Transaction confirmed: ${signature}`);
    
    // Update any active stop-losses with the transaction signature
    for (const [id, info] of this.activeStopLosses.entries()) {
      if (info.signature === '') {
        const updatedInfo = { ...info, signature };
        this.activeStopLosses.set(id, updatedInfo);
        break;
      }
    }
    
    return signature;
  }
  
  /**
   * Set risk percentage (1-100)
   */
  public setRiskPercentage(percentage: number): void {
    if (percentage <= 0 || percentage > 100) {
      throw new Error('Risk percentage must be between 1 and 100');
    }
    this.riskPercentage = percentage;
    console.log(`Risk percentage set to ${percentage}%`);
  }
  
  /**
   * Set minimum profit threshold in USD
   */
  public setMinProfitThreshold(amount: number): void {
    if (amount < 0) {
      throw new Error('Minimum profit threshold cannot be negative');
    }
    this.minProfitThreshold = amount;
    console.log(`Minimum profit threshold set to ${amount}`);
  }
}

// Example usage
async function main() {
  // Replace with your RPC endpoint and private key
  const bot = new SolanaTradeBot(
    'https://api.mainnet-beta.solana.com',
    'YOUR_PRIVATE_KEY_HERE'
  );
  
  // Configure risk management and profit thresholds
  bot.setRiskPercentage(30); // Risk 30% of account
  bot.setMinProfitThreshold(0.04); // Only trade if profit is at least $0.04
  
  // USDC and SOL mint addresses
  const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
  const SOL_MINT = 'So11111111111111111111111111111111111111112';
  
  // Attempt to trade 100 USDC for SOL (will be reduced to 30% of balance if needed)
  const result = await bot.trade(USDC_MINT, SOL_MINT, 100);
  
  if (result.profitThresholdMet) {
    console.log(`Trade is profitable: ${result.profitAmount.toFixed(4)}`);
    
    if (result.transaction) {
      const signature = await bot.sendTransaction(result.transaction);
      console.log(`Trade executed successfully: ${signature}`);
    } else {
      console.error('Failed to create transaction');
    }
  } else {
    console.log(`Trade skipped: Potential profit ${result.profitAmount.toFixed(4)} is below threshold of ${bot.minProfitThreshold}`);
  }
}

// Uncomment to run the example
// main().catch(console.error);

export default SolanaTradeBot;
